{"version":3,"file":"mfa.js","mappings":"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","sources":["webpack:///../../../../../node_modules/@simplewebauthn/browser/dist/bundle/index.js","webpack:///./js/mfa.js","webpack:///./js/webauthn.js"],"sourcesContent":["/* [@simplewebauthn/browser@7.1.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') ;\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort('Cancelling existing WebAuthn API call for new one');\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    var _a;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: (_a = creationOptionsJSON.excludeCredentials) === null || _a === void 0 ? void 0 : _a.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') ;\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import {browserSupportsWebAuthn} from '@simplewebauthn/browser';\n\n(function ($) {\n  /** global: Craft */\n  /** global: Garnish */\n  Craft.Mfa = Garnish.Base.extend(\n    {\n      $mfaLoginFormContainer: null,\n      $mfaSetupFormContainer: null,\n      $alternativeMfaLink: null,\n      $alternativeMfaTypesContainer: null,\n      $viewSetupBtns: null,\n      $errors: null,\n\n      $slideout: null,\n      $removeSetupButton: null,\n      $closeButton: null,\n      $verifyButton: null,\n\n      init: function (settings) {\n        this.$mfaLoginFormContainer = $('#mfa-form');\n        this.$mfaSetupFormContainer = $('#mfa-setup');\n        this.$alternativeMfaLink = $('#alternative-mfa');\n        this.$alternativeMfaTypesContainer = $('#alternative-mfa-types');\n        this.$viewSetupBtns = this.$mfaSetupFormContainer.find(\n          'button.mfa-view-setup'\n        );\n\n        this.setSettings(settings, Craft.Mfa.defaults);\n\n        this.addListener(\n          this.$alternativeMfaLink,\n          'click',\n          'onAlternativeMfaTypeClick'\n        );\n        this.addListener(this.$viewSetupBtns, 'click', 'onViewSetupBtnClick');\n      },\n\n      showMfaForm: function (mfaForm, $loginDiv) {\n        this.$mfaLoginFormContainer.html('').append(mfaForm);\n        $loginDiv.addClass('mfa');\n        $('#login-form-buttons').hide();\n        const $submitBtn = this.$mfaLoginFormContainer.find('.submit');\n        this.$errors = $('#login-errors');\n\n        this.onSubmitResponse($submitBtn);\n      },\n\n      getCurrentMfaType: function ($container) {\n        let currentMethod = $container.attr('data-mfa-type');\n\n        if (currentMethod === undefined) {\n          currentMethod = null;\n        }\n\n        return currentMethod;\n      },\n\n      submitLoginMfa: function () {\n        const $submitBtn = this.$mfaLoginFormContainer.find('.submit');\n        $submitBtn.addClass('loading');\n\n        let data = {\n          mfaFields: {},\n          currentMethod: null,\n        };\n\n        data.mfaFields = this._getMfaFields(this.$mfaLoginFormContainer);\n        data.currentMethod = this._getCurrentMethodInput(\n          this.$mfaLoginFormContainer\n        );\n\n        Craft.sendActionRequest('POST', 'users/verify-mfa', {data})\n          .then((response) => {\n            window.location.href = response.data.returnUrl;\n          })\n          .catch(({response}) => {\n            this.onSubmitResponse($submitBtn);\n\n            // Add the error message\n            this.showError(response.data.message);\n          });\n      },\n\n      onViewSetupBtnClick: function (ev) {\n        ev.preventDefault();\n\n        const data = {\n          selectedMethod: this.getCurrentMfaType($(ev.currentTarget)),\n        };\n\n        Craft.sendActionRequest('POST', this.settings.setupSlideoutHtml, {data})\n          .then((response) => {\n            this.slideout = new Craft.Slideout(response.data.html);\n\n            this.$errors = this.slideout.$container.find('.so-notice');\n            this.$closeButton = this.slideout.$container.find('button.close');\n\n            // initialise webauthn\n            if (\n              data.selectedMethod === 'craft\\\\mfa\\\\type\\\\WebAuthn' &&\n              browserSupportsWebAuthn()\n            ) {\n              new Craft.WebAuthn(this.slideout);\n            }\n\n            this.$verifyButton = this.slideout.$container.find('#mfa-verify');\n            this.$removeSetupButton =\n              this.slideout.$container.find('#mfa-remove-setup');\n\n            this.addListener(this.$removeSetupButton, 'click', 'onRemoveSetup');\n            this.addListener(this.$closeButton, 'click', 'onClickClose');\n            this.addListener(this.$verifyButton, 'click', 'onVerify');\n\n            this.slideout.on('close', (ev) => {\n              this.$removeSetupButton = null;\n              this.slideout = null;\n            });\n          })\n          .catch(({response}) => {\n            // Add the error message\n            Craft.cp.displayError(response.data.message);\n          });\n      },\n\n      onClickClose: function (ev) {\n        this.slideout.close();\n      },\n\n      onRemoveSetup: function (ev) {\n        ev.preventDefault();\n\n        let currentMethod = this.getCurrentMfaType(\n          this.slideout.$container.find('#mfa-setup-form')\n        );\n\n        if (currentMethod === undefined) {\n          currentMethod = null;\n        }\n\n        let data = {\n          currentMethod: currentMethod,\n        };\n\n        Craft.sendActionRequest('POST', this.settings.removeSetup, {data})\n          .then((response) => {\n            $(ev.currentTarget).remove();\n            Craft.cp.displayNotice(Craft.t('app', 'MFA setup removed.'));\n          })\n          .catch((e) => {\n            Craft.cp.displayError(e.response.data.message);\n          })\n          .finally(() => {\n            this.slideout.close();\n          });\n      },\n\n      onVerify: function (ev) {\n        ev.preventDefault();\n\n        const $submitBtn = this.slideout.$container.find('#mfa-verify');\n\n        $submitBtn.addClass('loading');\n\n        let data = {\n          mfaFields: {},\n          currentMethod: null,\n        };\n\n        data.mfaFields = this._getMfaFields(this.slideout.$container);\n        data.currentMethod = this._getCurrentMethodInput(\n          this.slideout.$container\n        );\n\n        Craft.sendActionRequest('POST', this.settings.saveSetup, {data})\n          .then((response) => {\n            this.onSubmitResponse($submitBtn);\n            Craft.cp.displayNotice(Craft.t('app', 'MFA settings saved.'));\n            this.slideout.close();\n          })\n          .catch(({response}) => {\n            this.onSubmitResponse($submitBtn);\n\n            // Add the error message\n            this.showError(response.data.message);\n            Craft.cp.displayError(response.data.message);\n          });\n      },\n\n      onSubmitResponse: function ($submitBtn) {\n        $submitBtn.removeClass('loading');\n      },\n\n      showError: function (error) {\n        this.clearErrors();\n\n        $('<p class=\"error\" style=\"display: none;\">' + error + '</p>')\n          .appendTo(this.$errors)\n          .velocity('fadeIn');\n      },\n\n      clearErrors: function () {\n        this.$errors.empty();\n      },\n\n      onAlternativeMfaTypeClick: function (event) {\n        // get current authenticator class via data-mfa-type\n        let currentMethod = this.getCurrentMfaType(\n          this.$mfaLoginFormContainer.find('#verifyContainer')\n        );\n        if (currentMethod === null) {\n          this.$alternativeMfaLink.hide();\n          this.showError(\n            Craft.t('app', 'No alternative MFA methods available.')\n          );\n        }\n\n        let data = {\n          currentMethod: currentMethod,\n        };\n\n        // get available MFA methods, minus the one that's being shown\n        this.getAlternativeMfaTypes(data);\n      },\n\n      getAlternativeMfaTypes: function (data) {\n        Craft.sendActionRequest(\n          'POST',\n          this.settings.fetchAlternativeMfaTypes,\n          {\n            data,\n          }\n        )\n          .then((response) => {\n            if (response.data.alternativeTypes !== undefined) {\n              this.showAlternativeMfaTypes(response.data.alternativeTypes);\n            }\n          })\n          .catch(({response}) => {\n            this.showError(response.data.message);\n          });\n      },\n\n      showAlternativeMfaTypes: function (data) {\n        let alternativeTypes = Object.entries(data).map(([key, value]) => ({\n          key,\n          value,\n        }));\n        if (alternativeTypes.length > 0) {\n          alternativeTypes.forEach((type) => {\n            this.$alternativeMfaTypesContainer.append(\n              '<li><button ' +\n                'class=\"alternative-mfa-type\" ' +\n                'type=\"button\" ' +\n                'value=\"' +\n                type.key +\n                '\">' +\n                type.value.name +\n                '</button></li>'\n            );\n          });\n        }\n\n        // list them by name\n        this.$alternativeMfaLink\n          .hide()\n          .after(this.$alternativeMfaTypesContainer);\n\n        // clicking on a method name swaps the form fields\n        this.addListener(\n          $('.alternative-mfa-type'),\n          'click',\n          'onSelectAlternativeMfaType'\n        );\n      },\n\n      onSelectAlternativeMfaType: function (event) {\n        const data = {\n          selectedMethod: $(event.currentTarget).attr('value'),\n        };\n\n        Craft.sendActionRequest('POST', this.settings.loadAlternativeMfaType, {\n          data,\n        })\n          .then((response) => {\n            if (response.data.mfaForm !== undefined) {\n              this.$mfaLoginFormContainer\n                .html('')\n                .append(response.data.mfaForm);\n              this.$alternativeMfaTypesContainer.html('');\n              this.$alternativeMfaLink.show();\n              this.onSubmitResponse();\n            }\n          })\n          .catch(({response}) => {\n            //this.showError(response.data.message);\n          });\n      },\n\n      _getMfaFields: function ($container) {\n        let mfaFields = {};\n\n        $container\n          .find('input[name^=\"mfaFields[')\n          .each(function (index, element) {\n            let name = $(element).attr('id');\n            mfaFields[name] = $(element).val();\n          });\n\n        return mfaFields;\n      },\n\n      _getCurrentMethodInput: function ($container) {\n        return $container.find('input[name=\"currentMethod\"').val();\n      },\n    },\n    {\n      defaults: {\n        fetchAlternativeMfaTypes: 'mfa/fetch-alternative-mfa-types',\n        loadAlternativeMfaType: 'mfa/load-alternative-mfa-type',\n        setupSlideoutHtml: 'mfa/setup-slideout-html',\n        saveSetup: 'mfa/save-setup',\n        removeSetup: 'mfa/remove-setup',\n      },\n    }\n  );\n})(jQuery);\n","import {browserSupportsWebAuthn} from '@simplewebauthn/browser';\nimport {startRegistration} from '@simplewebauthn/browser';\n\n(function ($) {\n  /** global: Craft */\n  /** global: Garnish */\n  Craft.WebAuthn = Garnish.Base.extend(\n    {\n      $addSecurityKeyBtn: null,\n      $errors: null,\n      slideout: null,\n\n      init: function (slideout, settings) {\n        this.slideout = slideout;\n        this.setSettings(settings, Craft.WebAuthn.defaults);\n        this.$addSecurityKeyBtn = $('#add-security-key');\n        this.$errors = this.slideout.$container.find('.so-notice');\n\n        if (!browserSupportsWebAuthn()) {\n          Craft.cp.displayError('This browser does not support WebAuth.');\n          this.$addSecurityKeyBtn.disable();\n        }\n\n        this.addListener(\n          this.$addSecurityKeyBtn,\n          'click',\n          'onAddSecurityKeyBtn'\n        );\n      },\n\n      onAddSecurityKeyBtn: function (ev) {\n        if (!$(ev.currentTarget).hasClass('disabled')) {\n          //this.setStatus(Craft.t('app', 'Waiting for elevated session'));\n          Craft.elevatedSessionManager.requireElevatedSession(\n            this.startWebAuthRegistration.bind(this),\n            this.failedElevation.bind(this)\n          );\n        }\n      },\n\n      failedElevation: function () {\n        console.log('not elevated from funct');\n      },\n\n      startWebAuthRegistration: function () {\n        console.log('elevated funct - start reg');\n        // GET registration options from the endpoint that calls\n        Craft.sendActionRequest(\n          'POST',\n          this.settings.generateRegistrationOptions\n        )\n          .then((response) => {\n            const registrationOptions = response.data.registrationOptions;\n            let startRegistrationResponse;\n            try {\n              startRegistrationResponse =\n                startRegistration(registrationOptions);\n            } catch (error) {\n              // Some basic error handling\n              if (error.name === 'InvalidStateError') {\n                Craft.cp.displayError(\n                  'Error: Authenticator was probably already registered by user'\n                );\n              } else {\n                Craft.cp.displayError(error);\n              }\n              throw error;\n            }\n\n            this.verifyWebAuthnRegistration(startRegistrationResponse);\n          })\n          .catch(({response}) => {\n            // todo: handle me\n            console.log(response);\n          });\n      },\n\n      verifyWebAuthnRegistration: function (startRegistrationResponse) {\n        console.log('verifyWebAuthnRegistration');\n        let data = {\n          credentials: JSON.stringify(startRegistrationResponse),\n        };\n\n        // POST the response to the endpoint\n        Craft.sendActionRequest('POST', this.settings.verifyRegistration, {\n          data,\n        })\n          .then((response) => {\n            // Show UI appropriate for the `verified` status\n            if (response.data.verified) {\n              Craft.cp.displaySuccess('Success!');\n            } else {\n              Craft.cp.displayError('Something went wrong!');\n              console.log(response);\n            }\n          })\n          .catch(({response}) => {\n            // todo: handle me\n            console.log(response);\n          });\n      },\n    },\n    {\n      defaults: {\n        generateRegistrationOptions: 'mfa/generate-registration-options',\n        verifyRegistration: 'mfa/verify-registration',\n      },\n    }\n  );\n})(jQuery);\n"],"names":["bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","undefined","window","PublicKeyCredential","toPublicKeyCredentialDescriptor","descriptor","id","transports","WebAuthnError","Error","constructor","message","name","super","this","webauthnAbortService","createNewAbortSignal","controller","abort","newController","AbortController","signal","attachments","toAuthenticatorAttachment","attachment","indexOf","$","jQuery","Craft","Mfa","Garnish","Base","extend","$mfaLoginFormContainer","$mfaSetupFormContainer","$alternativeMfaLink","$alternativeMfaTypesContainer","$viewSetupBtns","$errors","$slideout","$removeSetupButton","$closeButton","$verifyButton","init","settings","find","setSettings","defaults","addListener","showMfaForm","mfaForm","$loginDiv","html","append","addClass","hide","$submitBtn","onSubmitResponse","getCurrentMfaType","$container","currentMethod","attr","submitLoginMfa","data","mfaFields","_getMfaFields","_getCurrentMethodInput","sendActionRequest","then","response","location","href","returnUrl","showError","onViewSetupBtnClick","ev","preventDefault","selectedMethod","currentTarget","setupSlideoutHtml","slideout","Slideout","WebAuthn","on","cp","displayError","onClickClose","close","onRemoveSetup","removeSetup","remove","displayNotice","t","e","onVerify","saveSetup","removeClass","error","clearErrors","appendTo","velocity","empty","onAlternativeMfaTypeClick","event","getAlternativeMfaTypes","fetchAlternativeMfaTypes","alternativeTypes","showAlternativeMfaTypes","Object","entries","map","key","value","forEach","type","after","onSelectAlternativeMfaType","loadAlternativeMfaType","show","each","index","element","val","$addSecurityKeyBtn","disable","onAddSecurityKeyBtn","hasClass","elevatedSessionManager","requireElevatedSession","startWebAuthRegistration","bind","failedElevation","console","log","generateRegistrationOptions","startRegistrationResponse","registrationOptions","async","creationOptionsJSON","_a","options","publicKey","challenge","user","TextEncoder","encode","excludeCredentials","credential","navigator","credentials","create","err","_b","authenticatorSelection","requireResidentKey","userVerification","pubKeyCredParams","filter","param","effectiveDomain","hostname","test","rp","byteLength","identifyRegistrationError","rawId","getTransports","attestationObject","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","startRegistration","verifyWebAuthnRegistration","JSON","stringify","verifyRegistration","verified","displaySuccess"],"sourceRoot":""}